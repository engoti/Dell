"use strict";
const utils_1 = require("@typescript-eslint/utils");
const util_1 = require("../util");
const rule = (0, util_1.createRule)({
    name: "export-just-namespace",
    defaultOptions: [],
    meta: {
        type: "problem",
        docs: {
            description: "Forbids `export = foo` where `foo` is a namespace and isn't merged with a function/class/type/interface.",
            recommended: "error",
        },
        messages: {
            useTheBody: "Instead of `export =`-ing a namespace, use the body of the namespace as the module body.",
        },
        schema: [],
    },
    create(context) {
        const ast = context.getSourceCode().ast;
        const exportEqualsNode = ast.body.find(isExportEqualsWithIdentifier);
        if (!exportEqualsNode) {
            return {};
        }
        if (isJustNamespace(ast.body, exportEqualsNode.expression.name)) {
            context.report({
                messageId: "useTheBody",
                node: exportEqualsNode,
            });
        }
        return {};
    },
});
/**
 * @returns Where there is a namespace but there are no functions/classes/etc. with the same name.
 */
function isJustNamespace(statements, exportEqualsName) {
    let anyNamespace = false;
    for (const statement of statements) {
        switch (statement.type) {
            case utils_1.AST_NODE_TYPES.TSModuleDeclaration:
                anyNamespace || (anyNamespace = nameMatches(statement.id));
                break;
            case utils_1.AST_NODE_TYPES.VariableDeclaration:
                if (statement.declarations.some((d) => nameMatches(d.id))) {
                    // OK. It's merged with a variable.
                    return false;
                }
                break;
            case utils_1.AST_NODE_TYPES.ClassDeclaration:
            case utils_1.AST_NODE_TYPES.FunctionDeclaration:
            case utils_1.AST_NODE_TYPES.TSDeclareFunction:
            case utils_1.AST_NODE_TYPES.TSTypeAliasDeclaration:
            case utils_1.AST_NODE_TYPES.TSInterfaceDeclaration:
                if (nameMatches(statement.id)) {
                    // OK. It's merged with a function/class/type/interface.
                    return false;
                }
                break;
        }
    }
    return anyNamespace;
    function nameMatches(nameNode) {
        return !!nameNode && nameNode.type === utils_1.AST_NODE_TYPES.Identifier && nameNode.name === exportEqualsName;
    }
}
function isExportEqualsWithIdentifier(node) {
    return node.type === utils_1.AST_NODE_TYPES.TSExportAssignment && node.expression.type === utils_1.AST_NODE_TYPES.Identifier;
}
module.exports = rule;
//# sourceMappingURL=export-just-namespace.js.map